# 正则表达式

### 正则表达式的创建

1.构造函数创建

```js
var reg=new RegExp(正则内容,修饰符);
```

2.字面量创建

```js
var reg=/正则内容/修饰符
```

### 正则的修饰符

|  i   | 不区分大小写 |
| :--: | :----------: |
|  g   |   全局匹配   |
|  m   |   多行匹配   |

### 正则对象的方法

|  test   |   判断test()参数中的字符串中有没有匹配正则表达式内容   |
| :-----: | :----------------------------------------------------: |
|  exec   |   返回一个数组，表示exec()参数中字符串匹配正则的内容   |
| search  |      只能找到第一个不能全局匹配，返回找到内容下标      |
|  match  | 把找到匹配的元素用数组罗列，如果没有全局匹配和exec相同 |
| replace |      当使用全局匹配时，可以完成所有元素的匹配替换      |
|  split  |           用于把一个字符串分割成字符串数组。           |

### 匹配规则

| [abc]  | 查找方括号之间的任何字符       |
| :----: | ------------------------------ |
| [^abc] | 查找任何不在方括号之间的字符   |
| [0-9]  | 查找任何从0到9的数字           |
| [a-z]  | 查找任何从小写a到小写z的字符   |
| [A-Z]  | 查找任何从大写A到到大写Z的字符 |

### 元字符

| 元字符 |                 描述                 |
| :----: | :----------------------------------: |
|   .    |   查找单个字符，除了换行和行结束符   |
|   \w   | 查找单个字符，包括字母，数字和下划线 |
|   \W   |            查找非单个字符            |
|   \d   |               查找数字               |
|   \D   |            查找非数字字符            |
|   \s   |             查找空白字符             |
|   \S   |            查找非空白字符            |

```js
// 写在[]中的.就是转义字符.，不是通配符
console.log("ab.cd".match(/[ad.]/g));
// 所有的括号必须增加转义\
console.log("ab.cd".match(/[\{\}\[\]\(\)]/g));
// 两个\ 在字符或者正则表达式的[]都是一个\
console.log("aa\\a\a".match(/[\\]/g));
// 在[]内第一个字符是^，表示后面的字符不用，取反
console.log("abcdef".match(/[^d]/g));
console.log("abc^def".match(/[^\^]/g));//不要^
console.log("abc^def".match(/[a^c]/g));//如果^不是第一个，作为字符^使用
```

### 量词

|  量词  |               描述                |
| :----: | :-------------------------------: |
|   n+   |   匹配任何包含至少一个n的字符串   |
|   n*   |  匹配任何包含零个或多个n的字符串  |
|   n?   | 匹配任何包含零个或者一个n的字符串 |
|  n{X}  |    匹配包含X个n的序列的字符串     |
| n{X,Y} | 匹配包含X个或者Y个n的序列的字符串 |
| n{X,}  |    匹配至少X个n的序列的字符串     |
|   n$   |      匹配任何结尾为n的字符串      |
|   ^n   |      匹配任何开头为n的字符串      |

正则中需要使用转义斜杠的字符

^  .  $  *  +  ?  [  ]   (   )   {   }   \  /  |

### 正则表达式的基础语法

#### 字符

大部分字符包括数字和字母字符是普通字符，他们只能匹配他们自己。不做特殊说明，正则表达式中是区分大小写的。

"."可以匹配所有字符，称之为通配符

[abcdefghi] 匹配其中任意一个

写在[]中的.就是转义字符.，不是通配符。。

```js
// 写在[]中的.就是转义字符.，不是通配符
console.log("ab.cd".match(/[ad.]/g));
// 所有的括号必须增加转义\
console.log("ab.cd".match(/[\{\}\[\]\(\)]/g));
// 两个\ 在字符或者正则表达式的[]都是一个\
console.log("aa\\a\a".match(/[\\]/g));
console.log("ab12nfs2".match(/[0-9]/g))
[0-20]  [0-2 0] === [0-2]
console.log("134".match(/[0-20]/g));
/[aaaazzzzdddd]/  无意义  /[azd]/
console.log("aZsw".match(/[a-Z]/g));//错误的Unicode编码中a比Z大
console.log("aZsw".match(/[A-z]/g));//错误大写Z到a中间还有其他字符串
         console.log("aa\\aa\a".match(/\\/g));
```

```js
console.log("abcdef".match(/[a-ce-z]/g));
//在[]内第一个字符是^，表示后面的字符不用，取反
console.log("abcdef".match(/[^d]/g));
console.log("abc^def".match(/[^\^]/g));//不要^
console.log("abc^def".match(/[a^c]/g));//如果^不是第一个，作为字符^使用

console.log("abcdfeas".match(/[a-zA-Z0-9_]/g));
console.log("abcdfeas".match(/\w/g));
console.log("abcdfeas".match(/\W/g));//  /[^a-zA-Z0-9_]/g
console.log("28wdhd8223".match(/\d/g));//   [0-9]
console.log("28wdhd8223".match(/\D/g));//   [^0-9]

console.log("asd shw".match(/\s/g));// 空格
console.log("asd shw".match(/\S/g));// 非空格
        
```


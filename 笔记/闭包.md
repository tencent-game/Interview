# 闭包

```js
function fn1{
    var a=1;
    //因为返回的函数被存储在全局变量中，并且这个返回的函数中使用了这个a的局部变量，因此a被保存在堆中
    return function(){
        a++;
        console.log(a)
    }
}
var f=fn1()
如果a是一个对象，在f()执行完之后a并不会被回收，仍会留在堆中

```

闭包是指有权访问另一个函数作用域中的变量的函数。

闭包的原因：返回的函数并非是孤立的函数，而是连同周围的环境打了个包，形成了一个封闭的环境包，共同返回出来

闭包会导致内存泄漏。

特点：函数嵌套函数

​			里面函数可以引用外部的参数与变量

​			外部函数参数和变量不会被垃圾回收机制回收

优点：希望一个变量长期驻扎在内存中

​			避免全局变量的污染

​			私有成员的存在







要理解闭包先得了解作用域与作用域链，函数的作用域就是变量和函数可以访问的范围，函数的作用域分为全局作用域与局部作用域两种。

###### 全局作用域：

在代码中任何地方都能访问到的对象具有全局作用域。一般分为以下几种情况：

①最外层函数与在最外层函数定义的变量拥有全局作用域

②所有未定义直接赋值的变量自动声明为拥有全局作用域

③所有window对象的属性拥有全局作用域

###### 局部作用域：

指在固定的代码片段中才可以访问到的。例如函数体内。

###### 作用域链

当一个函数创建时，他的作用域链就会被创建此函数的作用域中可访问的数据对象填充。

作用域链的前端，始终都是当前代码治所在环境的变量对象。

作用域链中的下一个对象来自外部环境，再下一个变量对象来自下一个外部环境，一直到全局执行环境

全局执行环境的变量对象始终都是在作用域链的最后一个对象。

注意：内部环境可以通过作用域链访问外部环境，但外部环境不能访问内部环境中的任何变量和函数。

在内部函数中。如果需要访问一个变量，首先访问函数本身的变量对象，查看是否有这个变量，如果没有就沿着作用域往上查找，知道全局作用域。如果在某个变量对象中找到则使用该变量对象的变量值

上面的机制也决定了访问局部变量要比访问全局变量要更快，因为中间的查找时间更短

闭包的定义：闭包是指有权访问另一个函数作用域中的变量的函数。

每个函数都有自己的执行环境，一个执行环境关联一个变量对象，变量对象的集合叫作用域链。按理来说在代码执行完毕后所在的环境会被销毁，即便是全局环境也会在应用退出时销毁，但是当函数内部的函数调用函数的变量与参数时这些变量与参数别不会被回收。

### 柯里化（currying）

柯里化是指收集输入的参数，直到没有参数传入时执行函数操作后返回操作后的结果，换言之就是将一个使用多个参数的函数转化为使用一个参数的函数的技术。

```js
function curry(fn){
        var arr=[];
        return function(){
            if(arguments.length>0){
                arr=arr.concat(Array.from(arguments));
                return arguments.callee;
            }else{
               return  fn.apply(null,arr);
            }
           
        }
    }

    function fns(){
        return Array.from(arguments).reduce((value,item)=>value+=item);
    }


  var s=fns(1,2,3,4,5,6)
    console.log(s);
    var sum=curry(fns);
   var s=sum(1)(2,3)(4,5,6)()
   console.log(s);
```

函数柯里化就是让高阶函数降阶的过程，是为了缩小适用范围，创建一个针对性更强的函数。而反柯里化就是让一个针对性函数升阶成为高阶函数，使其适用范围更广，让方法的使用场景更大

柯里化是在运算前提前传参，可以传递多个参数。

反柯里化是延迟传参，在运算时，把原来固定的参数或者this上下文等都当做参数延迟到未来传递。



